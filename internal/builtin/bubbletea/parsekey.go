package bubbletea

import (
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/rivo/uniseg"
)

// ParseKey parses a string representation of a key event
// (as generated by Key.String()) back into a Key struct.
//
// The boolean indicates whether the parsing was unambiguous.
//
// It handles:
// 1. "alt+" modifiers
// 2. Bracketed paste format "[...]"
// 3. Named keys (e.g., "enter", "ctrl+c")
// 4. Raw runes (as a fallback)
// 5. All zero values (if input is empty string)
//
// Case 4 returns false if the (non-alt) string is not a single printable
// character AND not a single rune. N.B. The special case " " (space) is
// therefore the sole single printable character key that doesn't return true.
func ParseKey(s string) (tea.Key, bool) {
	var k tea.Key

	// 5. Return all zero values
	if s == "" {
		return k, false
	}

	// 1. Handle Alt modifier
	// Key.String() prepends "alt+" before processing the type.
	// We strip it first to handle things like "alt+enter" or "alt+a".
	const altPrefix = "alt+"
	if strings.HasPrefix(s, altPrefix) {
		k.Alt = true
		s = s[len(altPrefix):]
	}

	// 2. Handle Paste
	// Key.String() wraps pasted content in square brackets.
	// We check for this format to restore the Paste flag.
	if len(s) > 2 && strings.HasPrefix(s, "[") && strings.HasSuffix(s, "]") {
		k.Paste = true
		k.Type = tea.KeyRunes
		k.Runes = []rune(s[1 : len(s)-1])
		return k, true
	}

	// 3. Handle Named Keys (KeyType)
	// Check against the reverse map of keyNames (e.g., "enter" -> KeyEnter).
	if t, ok := KeyDefs[s]; ok {
		k.Type = t.Type

		// N.B. The legacy " " special case is returned here. It should've been KeyRunes.
		if t.Type == tea.KeySpace {
			k.Runes = []rune(s)
		}

		return k, true
	}

	// 4. Handle Raw Runes (as a fallback)
	k.Type = tea.KeyRunes
	k.Runes = []rune(s)

	// return false if "ambiguous" - basically just a special cased "multiple runes" check
	return k, len(s) == 1 ||
		len(k.Runes) == 1 ||
		// monospace single-width characters are unambiguous
		uniseg.StringWidth(s) == 1
}
