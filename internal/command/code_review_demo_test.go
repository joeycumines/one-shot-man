package command

import (
	"bytes"
	"context"
	"strings"
	"testing"

	"github.com/joeycumines/one-shot-man/internal/scripting"
	"github.com/joeycumines/one-shot-man/internal/testutil"
)

func TestCodeReviewCommand_ShowActualDiffOutput(t *testing.T) {
	// This test demonstrates the actual output generated by the code-review command
	// including lazy diff execution

	ctx := context.Background()
	var stdout, stderr bytes.Buffer
	// Use an in-memory storage backend with a test-scoped session to avoid
	// polluting the user's real session files during tests.
	engine, err := scripting.NewEngineWithConfig(ctx, &stdout, &stderr, testutil.NewTestSessionID("code-review", t.Name()), "memory")
	if err != nil {
		t.Fatalf("NewEngine failed: %v", err)
	}
	defer engine.Close()

	engine.SetTestMode(true)
	engine.SetGlobal("args", []string{})
	engine.SetGlobal("codeReviewTemplate", codeReviewTemplate)
	// Inject config object with name field
	engine.SetGlobal("config", map[string]interface{}{"name": "code-review"})

	// Load the script
	script := engine.LoadScriptFromString("code-review", codeReviewScript)
	if err := engine.ExecuteScript(script); err != nil {
		t.Fatalf("Failed to execute script: %v", err)
	}

	// Explicitly switch to code-review mode using Go-level call to ensure mode is fully initialized
	tuiManager := engine.GetTUIManager()
	if err := tuiManager.SwitchMode("code-review"); err != nil {
		t.Fatalf("Failed to switch to code-review mode: %v", err)
	}

	// Test the complete workflow: add diff, then generate prompt
	testScript := `
		output.print("=== TESTING CODE REVIEW DIFF FUNCTIONALITY ===");

		// Step 1: Add a lazy diff (default HEAD~1)
		// Note: commands is a global set when mode is entered
		commands.diff.handler([]);

		// Show what was added
		output.print("After adding diff:");
		commands.list.handler();

		// Step 2: Generate the prompt (this should execute the lazy diff)
		output.print("\\n=== GENERATING PROMPT ===");
		const prompt = buildPrompt();

		// Show the final prompt
		output.print("\\n=== FINAL PROMPT OUTPUT ===");
		output.print(prompt);

		// Show updated list after prompt generation
		output.print("\\n=== ITEMS AFTER PROMPT GENERATION ===");
		commands.list.handler();

		output.print("\\n=== END TEST ===");
	`

	testScriptObj := engine.LoadScriptFromString("demo-test", testScript)
	err = engine.ExecuteScript(testScriptObj)
	if err != nil {
		t.Fatalf("Demo script execution failed: %v", err)
	}

	output := stdout.String()
	t.Logf("Code Review Output:\n%s", output)

	// Verify key elements are present
	if !strings.Contains(output, "TESTING CODE REVIEW DIFF FUNCTIONALITY") {
		t.Errorf("Missing test start marker")
	}

	if !strings.Contains(output, "GUARANTEE the correctness") {
		t.Errorf("Missing expected prompt text")
	}

	if !strings.Contains(output, "lazy-diff") || !strings.Contains(output, "diff") {
		t.Errorf("Diff execution may not be working properly")
	}
}
