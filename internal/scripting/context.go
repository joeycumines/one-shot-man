package scripting

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"golang.org/x/tools/txtar"
)

// ContextManager handles tracking and managing file paths and content as context
// for building LLM prompts.
type ContextManager struct {
	paths    map[string]*ContextPath
	basePath string
	mutex    sync.RWMutex
}

// ContextPath represents a tracked file or directory with metadata.
type ContextPath struct {
	Path        string            `json:"path"`
	Type        string            `json:"type"` // "file" or "directory"
	Content     string            `json:"content,omitempty"`
	Metadata    map[string]string `json:"metadata"`
	Children    []string          `json:"children,omitempty"` // for directories
	LastUpdated int64             `json:"lastUpdated"`
}

// NewContextManager creates a new context manager.
func NewContextManager(basePath string) *ContextManager {
	return &ContextManager{
		paths:    make(map[string]*ContextPath),
		basePath: basePath,
	}
}

// AddPath adds a file or directory to the context.
func (cm *ContextManager) AddPath(path string) error {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	absPath, err := filepath.Abs(path)
	if err != nil {
		return fmt.Errorf("failed to get absolute path: %w", err)
	}

	// Normalize path to be relative to base path if possible
	relPath, err := filepath.Rel(cm.basePath, absPath)
	if err != nil {
		relPath = absPath
	}

	info, err := os.Stat(absPath)
	if err != nil {
		return fmt.Errorf("failed to stat path %s: %w", path, err)
	}

	contextPath := &ContextPath{
		Path:        relPath,
		Metadata:    make(map[string]string),
		LastUpdated: info.ModTime().Unix(),
	}

	if info.IsDir() {
		contextPath.Type = "directory"
		children, err := cm.scanDirectory(absPath)
		if err != nil {
			return fmt.Errorf("failed to scan directory %s: %w", path, err)
		}
		contextPath.Children = children
	} else {
		contextPath.Type = "file"
		content, err := os.ReadFile(absPath)
		if err != nil {
			return fmt.Errorf("failed to read file %s: %w", path, err)
		}
		contextPath.Content = string(content)
		contextPath.Metadata["size"] = fmt.Sprintf("%d", len(content))
		contextPath.Metadata["extension"] = filepath.Ext(relPath)
	}

	cm.paths[relPath] = contextPath
	return nil
}

// RemovePath removes a path from the context.
func (cm *ContextManager) RemovePath(path string) error {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	delete(cm.paths, path)
	return nil
}

// GetPath returns information about a tracked path.
func (cm *ContextManager) GetPath(path string) (*ContextPath, bool) {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()

	contextPath, exists := cm.paths[path]
	return contextPath, exists
}

// ListPaths returns all tracked paths.
func (cm *ContextManager) ListPaths() []string {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()

	paths := make([]string, 0, len(cm.paths))
	for path := range cm.paths {
		paths = append(paths, path)
	}
	return paths
}

// ToTxtar converts the context to txtar format.
func (cm *ContextManager) ToTxtar() *txtar.Archive {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()

	archive := &txtar.Archive{
		Comment: []byte("Context archive generated by one-shot-man"),
	}

	for _, contextPath := range cm.paths {
		if contextPath.Type == "file" {
			file := txtar.File{
				Name: contextPath.Path,
				Data: []byte(contextPath.Content),
			}
			archive.Files = append(archive.Files, file)
		}
	}

	return archive
}

// FromTxtar loads context from a txtar archive.
func (cm *ContextManager) FromTxtar(archive *txtar.Archive) error {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	// Clear existing context
	cm.paths = make(map[string]*ContextPath)

	for _, file := range archive.Files {
		contextPath := &ContextPath{
			Path:     file.Name,
			Type:     "file",
			Content:  string(file.Data),
			Metadata: make(map[string]string),
		}
		contextPath.Metadata["size"] = fmt.Sprintf("%d", len(file.Data))
		contextPath.Metadata["extension"] = filepath.Ext(file.Name)

		cm.paths[file.Name] = contextPath
	}

	return nil
}

// GetTxtarString returns the context as a txtar-formatted string.
func (cm *ContextManager) GetTxtarString() string {
	archive := cm.ToTxtar()
	return string(txtar.Format(archive))
}

// LoadFromTxtarString loads context from a txtar-formatted string.
func (cm *ContextManager) LoadFromTxtarString(data string) error {
	archive := txtar.Parse([]byte(data))
	return cm.FromTxtar(archive)
}

// RefreshPath updates the content of a tracked path.
func (cm *ContextManager) RefreshPath(path string) error {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	contextPath, exists := cm.paths[path]
	if !exists {
		return fmt.Errorf("path %s is not tracked", path)
	}

	absPath := filepath.Join(cm.basePath, path)
	info, err := os.Stat(absPath)
	if err != nil {
		return fmt.Errorf("failed to stat path %s: %w", path, err)
	}

	contextPath.LastUpdated = info.ModTime().Unix()

	if contextPath.Type == "file" {
		content, err := os.ReadFile(absPath)
		if err != nil {
			return fmt.Errorf("failed to read file %s: %w", path, err)
		}
		contextPath.Content = string(content)
		contextPath.Metadata["size"] = fmt.Sprintf("%d", len(content))
	} else if contextPath.Type == "directory" {
		children, err := cm.scanDirectory(absPath)
		if err != nil {
			return fmt.Errorf("failed to scan directory %s: %w", path, err)
		}
		contextPath.Children = children
	}

	return nil
}

// scanDirectory scans a directory and returns relative paths of its contents.
func (cm *ContextManager) scanDirectory(dirPath string) ([]string, error) {
	var children []string

	err := filepath.WalkDir(dirPath, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if path == dirPath {
			return nil // Skip the directory itself
		}

		relPath, err := filepath.Rel(cm.basePath, path)
		if err != nil {
			relPath = path
		}

		children = append(children, relPath)
		return nil
	})

	return children, err
}

// GetStats returns statistics about the context.
func (cm *ContextManager) GetStats() map[string]interface{} {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()

	stats := map[string]interface{}{
		"totalPaths":  len(cm.paths),
		"files":       0,
		"directories": 0,
		"totalSize":   0,
	}

	for _, contextPath := range cm.paths {
		if contextPath.Type == "file" {
			stats["files"] = stats["files"].(int) + 1
			if sizeStr, ok := contextPath.Metadata["size"]; ok {
				var size int
				fmt.Sscanf(sizeStr, "%d", &size)
				stats["totalSize"] = stats["totalSize"].(int) + size
			}
		} else {
			stats["directories"] = stats["directories"].(int) + 1
		}
	}

	return stats
}

// FilterPaths returns paths matching the given pattern.
func (cm *ContextManager) FilterPaths(pattern string) ([]string, error) {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()

	var matches []string
	for path := range cm.paths {
		matched, err := filepath.Match(pattern, path)
		if err != nil {
			return nil, fmt.Errorf("invalid pattern %s: %w", pattern, err)
		}
		if matched {
			matches = append(matches, path)
		}
	}

	return matches, nil
}

// GetFilesByExtension returns all files with the given extension.
func (cm *ContextManager) GetFilesByExtension(ext string) []string {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()

	var files []string
	if !strings.HasPrefix(ext, ".") {
		ext = "." + ext
	}

	for path, contextPath := range cm.paths {
		if contextPath.Type == "file" && strings.HasSuffix(path, ext) {
			files = append(files, path)
		}
	}

	return files
}
